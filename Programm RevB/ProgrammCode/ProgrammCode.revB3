// Arduino Nano, OldBootlader, Pin A4 SDA & Pin A5 SCK(SCL)

#include <Wire.h>             //lib für I2C Kommunikation
#include <Adafruit_SH1106.h>  //lib fürs Display
#include <RTClib.h>           //lib für das RTC Modul
#include <Arduino.h>          //lib
#include <uEEPROMLib.h>       //lib für das lesen/scheiben vom EEPROM
#define OLED_RESET 4          //keine Ahnung, aber ohne gehts nicht
#define ADR_OpenStunde 0      //some naice idea
#define ADR_OpenMinute 1
#define ADR_CloseStunde 2
#define ADR_CloseMinute 3

RTC_DS3231 rtc;                       //"rtc" definieren
uEEPROMLib eeprom(0x57);              //Adresse des EEPROM definieren
Adafruit_SH1106 display(OLED_RESET);  //Display, keine Ahnung wofür aber ohne gehts nicht
const int DoorPin = 14;               //Pin für die Steuerung der Tür auf A0/Pin 14 legen
const int TasterTuer = 2;             //Pin für den TürToggler auf D2/ Pin 2 legen
const int TasterDisplay = 3;          //Pin für den DisplayKnopf auf D3/Pin 3 legen
int UhrZeitZahl;                      //ein paar Variablen initieren
int OpenZeitZahl;
int CloseZeitZahl;
int adresse;
int OpenStunde;
int OpenMinute;
int CloseStunde;
int CloseMinute;
int DisplayTimer;
bool PreDoorBool;
bool DoorBool;
bool OverwriteDoor;
bool ForceDoorAuf;
bool ForceDoorZu;
bool DisplayAn;

void setup() {
  pinMode(DoorPin, OUTPUT);              //Pinmodus festlegen
  pinMode(TasterTuer, INPUT_PULLUP);     //Pinmodus festlegen
  pinMode(TasterDisplay, INPUT_PULLUP);  //Pinmodus festlegen
  pinMode(LED_BUILTIN, OUTPUT);          //Interne LED ansteuern

  display.begin(SH1106_SWITCHCAPVCC, 0x3C);  //something for display again
  display.setTextSize(1);                    //größe der Schrift
  display.setTextColor(WHITE);               //farbe der Schrift
  display.clearDisplay();                    //Display blank putzen
  display.display();                         //dem Display sagen die vorherigen Anweisungen durch zu führen

  //die untere IF-Schleife für den Fall das der RTC nicht gefunden wird
  if (!rtc.begin()) {
    display.setCursor(0, 0);
    display.println("Zeitgeber");
    display.setCursor(0, 8);
    display.println("nicht gefunden!");
    display.display();
    digitalWrite(LED_BUILTIN, HIGH);
    while (1) delay(1000);
  }

  //die untere IF-Schleife für den Fall das der RTC die Zeit vergessen hat
  if (rtc.lostPower()) {
    display.setCursor(0, 0);
    display.print("Batterie des");
    display.setCursor(0, 8);
    display.print("Zeitgebers leer!");
    display.display();
    digitalWrite(LED_BUILTIN, HIGH);
    while (1) delay(1000);
  }

  OverwriteDoor = 0;
  PreDoorBool = 0;
  ForceDoorAuf = 0;
  ForceDoorZu = 0;
  DisplayTimer = 0;
  DisplayAn = 1;
}


void loop() {
  DateTime now = rtc.now();  //jetzt holen

  adresse = (((now.month() - 1) * 31) + now.day()) * 10;        //Fancy calculation um jedem Tag im Jahr eine eindeutige Adresse im EEPROM zu zu weisen
  OpenStunde = eeprom.eeprom_read(adresse + ADR_OpenStunde);    //Die Zahl der Stunde zum öffnen ausm EEPROM ziehen und in die Variable legen
  OpenMinute = eeprom.eeprom_read(adresse + ADR_OpenMinute);    //wie oben nur als Minute
  CloseStunde = eeprom.eeprom_read(adresse + ADR_CloseStunde);  //wie oben nur als Stunde zum schließen
  CloseMinute = eeprom.eeprom_read(adresse + ADR_CloseMinute);  //wie oben nur als Minute

  UhrZeitZahl = (now.hour() * 100) + now.minute();    //Zahl der aktuellen Uhrzeit berechnen
  OpenZeitZahl = (OpenStunde * 100) + OpenMinute;     //Zahl der Öffnezeit berechnen
  CloseZeitZahl = (CloseStunde * 100) + CloseMinute;  //Zahl der Schließzeit berechnen

  //_____Tür öffnen routine die Erste für die Priorisierung
  if ((UhrZeitZahl >= OpenZeitZahl) && (UhrZeitZahl <= CloseZeitZahl)) {
    PreDoorBool = 1;  //DoorBoolean ist 1 = Tür auf
  } else {
    PreDoorBool = 0;  //DoorBoolean ist 0 = Tür zu
  }

  //_____Displaytaster abfragen
  if (digitalRead(TasterDisplay) == 0) {
    DisplayAn = 1;
  }

  //_____Türtaster abfragen
  if (digitalRead(TasterTuer) == 0) {
    OverwriteDoor = 1;
    DisplayAn = 1;
  }

  //_____Wenn Tür zu, aber Taster gedrückt
  if ((PreDoorBool == 0) && (OverwriteDoor == 1)) {
    ForceDoorAuf = 1;
  }

  //_____Wenn Tür auf, aber Taster gedrückt
  if ((PreDoorBool == 1) && (OverwriteDoor == 1)) {
    ForceDoorZu = 1;
  }

  //_____Wenn die Uhrzeit = regulären Schließzeit oder Öffnezeit ist, das Überschreiben der Tür deaktivieren
  if ((UhrZeitZahl == CloseZeitZahl) || (UhrZeitZahl == OpenZeitZahl)) {
    OverwriteDoor = 0;
    ForceDoorZu = 0;
    ForceDoorAuf = 0;
  }

  //_____Wenn die Tür vor der regulären Zeit geöffnet werden soll...
  if (ForceDoorAuf == 1) {
    OpenZeitZahl = UhrZeitZahl - 1;  //... die Öffnezeit eine Minute *hinter* die aktuelle Zeit legen
  }

  //_____Wenn die Tür vor der regulären Zeit geschlossen werden soll...
  if (ForceDoorZu == 1) {
    CloseZeitZahl = UhrZeitZahl - 1;  //... die Schleißzeit eine Minute *hinter* die aktuelle Zeit legen
  }

  //_____Tür öffnen routine die Zweite für die Umsetzung
  if ((UhrZeitZahl >= OpenZeitZahl) && (UhrZeitZahl <= CloseZeitZahl)) {
    DoorBool = 1;  //DoorBoolean ist 1 = Tür auf
  } else {
    DoorBool = 0;  //DoorBoolean ist 0 = Tür zu
  }

  digitalWrite(DoorPin, !DoorBool);  //Invertierte DoorBoolean schreiben, da der Ausgang active Low ist

  //_____Wenn das Display 60sec an war, die DisplayBoolean und den Timer zurück setzten
  if (DisplayTimer == 60) {
    display.clearDisplay();
    display.display();
    DisplayAn = 0;
    DisplayTimer = 0;
  }

  //_____Falls der Displayknopf gedrückt wurde allerei Kram aufs Display schreiben
  if (DisplayAn == 1) {
    display.clearDisplay();

    display.setCursor(0, 0);              //oben links im Display
    char buf1[] = "DDD DD.MM.YYYY";       //Jetzt als lesbaren Datumstext ummodeln
    display.println(now.toString(buf1));  //und aufs Display legen

    display.setCursor(0, 8);            //zweite Reihe im Display
    char buf2[] = "hh:mm:ss";           //Jetzt als lesbaren Uhrzeittext ummodeln
    display.print(now.toString(buf2));  //und aufs Display legen
    display.print(" Sommerzeit");       //mit der Info das der RTC immer auf Sommerzeit läuft

    char buf[22];
    display.setCursor(0, 16);
    snprintf(buf, sizeof(buf), "Auf ab:  %02d:%02d Uhr", OpenStunde, OpenMinute);
    display.print(buf);  // Öffnezeit anzeigen

    display.setCursor(0, 24);
    snprintf(buf, sizeof(buf), "Zu ab:   %02d:%02d Uhr", CloseStunde, CloseMinute);
    display.print(buf);  // Schließzeit anzeigen

    if (OverwriteDoor == 1) {
      display.setCursor(0, 32);
      display.print("Tur vorzeitig bewegt");
      display.drawPixel(7, 32, WHITE);
      display.drawPixel(9, 32, WHITE);
    }

    display.setCursor(0, 40);
    if (DoorBool == 1) {
      display.print("Relais an / Tur auf");
      display.drawPixel(79, 40, WHITE);
      display.drawPixel(81, 40, WHITE);
    }

    if (DoorBool == 0) {
      display.print("Relais aus / Tur zu");
      display.drawPixel(85, 40, WHITE);
      display.drawPixel(87, 40, WHITE);
    }

    display.setCursor(0, 48);
    display.print("Taster: ");
    display.print(!digitalRead(TasterTuer));  //Status des Türtasters aufs Display legen
    display.print("T / ");
    display.print(!digitalRead(TasterDisplay));  //Status des Türtasters aufs Display legen
    display.print("D");

    display.setCursor(0, 56);
    display.print("Temperatur: ");
    display.print(rtc.getTemperature());
    display.print("'C");  //Temperatur ausm RTC holen und aufs Display legen

    display.display();  //Jezt alles aufs Display

    DisplayTimer = DisplayTimer + 1;  //den Displaytimer um 1 erhöhen
  }

  delay(1000);  //1 Sekunde Warten
}
