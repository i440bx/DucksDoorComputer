// Arduino Nano, OldBootlader, Pin A4 SDA & Pin A5 SCK(SCL)

#include <Wire.h>             //lib für I2C Kommunikation
#include <Adafruit_SH1106.h>  //lib fürs Display
#include <RTClib.h>           //lib für das RTC Modul
#include <Arduino.h>          //lib
#include <uEEPROMLib.h>       //lib für das lesen/scheiben vom EEPROM
#define OLED_RESET 4          //keine Ahnung, aber ohne gehts nicht
#define ADR_OpenStunde 0      //some naice idea
#define ADR_OpenMinute 1
#define ADR_CloseStunde 2
#define ADR_CloseMinute 3

RTC_DS3231 rtc;                       //"rtc" definieren
uEEPROMLib eeprom(0x57);              //Adresse des EEPROM definieren
Adafruit_SH1106 display(OLED_RESET);  //keine Ahnung, aber ohne gehts nicht
const int DoorPin = 14;               //Pin für die Steuerung der Tür auf A0/14 legen
const int Taster = 2;                 //Pin für den Türöffner auf D12/12 legen
int UhrZeitZahl;                      //ein paar Variablen initieren
int OpenZeitZahl;
int CloseZeitZahl;
int adresse;
int OpenStunde;
int OpenMinute;
int CloseStunde;
int CloseMinute;
bool DoorBool;
bool TasterSet;

void setup() {
  pinMode(DoorPin, OUTPUT);       //Pinmodus festlegen
  pinMode(Taster, INPUT_PULLUP);  //Pinmodus festlegen
  pinMode(LED_BUILTIN, OUTPUT);   //Interne LED ansteuern
  digitalWrite(DoorPin, HIGH);    //Pin erstmal hoch ziehen damit die Tür aufgeht bleibt [Relais inaktiv]
  TasterSet = 0;

  Serial.begin(9600);                        //Durch das Display vorgegeben, schneller leufts nicht
  display.begin(SH1106_SWITCHCAPVCC, 0x3C);  //something for display again
  display.setTextSize(1);                    //größe der Schrift
  display.setTextColor(WHITE);               //farbe der Schrift
  display.clearDisplay();                    //Display blank putzen
  display.display();                         //dem Display sagen die vorherigen Anweisungen durch zu führen

  //die untere IF-Schleife für den Fall das der RTC nicht gefunden wird
  if (!rtc.begin()) {
    display.setCursor(0, 0);
    display.println("Zeitgeber nicht gefunden!");
    display.display();
    digitalWrite(LED_BUILTIN, HIGH);
    while (1) delay(100);
  }

  //die untere IF-Schleife für den Fall das der RTC die Zeit vergessen hat
  if (rtc.lostPower()) {
    display.setCursor(0, 0);
    display.print("Batterie des");
    display.setCursor(0, 8);
    display.print("Zeitgebers leer!");
    display.display();
    digitalWrite(LED_BUILTIN, HIGH);
    while (1) delay(1000);
  }
}


void loop() {
  DateTime now = rtc.now();  //jetzt holen

  display.clearDisplay();

  display.setCursor(0, 0);              //oben links im Display
  char buf1[] = "DDD DD.MM.YYYY";       //Jetzt als lesbaren Datumstext ummodeln
  display.println(now.toString(buf1));  //und aufs Display legen

  display.setCursor(0, 8);            //zweite Reihe im Display
  char buf2[] = "hh:mm:ss";           //Jetzt als lesbaren Uhrzeittext ummodeln
  display.print(now.toString(buf2));  //und aufs Display legen
  display.print(" Sommerzeit");       //mit der Info das der RTC auf Sommerzeit läuft

  adresse = (((now.month() * 31) - 31) + now.day()) * 10;       //Fancy calculation um jedem Tag im Jahr eine eindeutige Adresse im EEPROM zu zu weisen
  OpenStunde = eeprom.eeprom_read(adresse + ADR_OpenStunde);    //Die Zahl der Stunde zum öffnen ausm EEPROM ziehen und in die Variable legen
  OpenMinute = eeprom.eeprom_read(adresse + ADR_OpenMinute);    //wie oben nur als Minute
  CloseStunde = eeprom.eeprom_read(adresse + ADR_CloseStunde);  //wie oben nur als Stunde zum schließen
  CloseMinute = eeprom.eeprom_read(adresse + ADR_CloseMinute);  //wie oben nur als Minute


  char buf[22];
  display.setCursor(0, 16);
  snprintf(buf, sizeof(buf), "Auf ab:  %02d:%02d Uhr", OpenStunde, OpenMinute);
  display.print(buf);  // Öffnezeit anzeigen

  display.setCursor(0, 24);
  snprintf(buf, sizeof(buf), "Zu ab:   %02d:%02d Uhr", CloseStunde, CloseMinute);
  display.print(buf);  // Schließzeit anzeigen

  UhrZeitZahl = (now.hour() * 100) + now.minute();
  OpenZeitZahl = (OpenStunde * 100) + OpenMinute;
  CloseZeitZahl = (CloseStunde * 100) + CloseMinute;

  if (digitalRead(Taster) == 0) {
    TasterSet = 1;
  }

  display.setCursor(0, 48);
  display.print("Taster: ");
  display.print(!digitalRead(Taster));

  if (UhrZeitZahl == 0) {
    TasterSet = 0;
  }

  if (TasterSet == 1) {
    CloseZeitZahl = UhrZeitZahl - 1;
  }

  //digitalWrite(DoorPin, !digitalRead(DoorPin));

  //Tür öffnen routine
  if ((UhrZeitZahl > OpenZeitZahl) && (UhrZeitZahl < CloseZeitZahl)) {
    DoorBool = 0;  //Pin low bedeutet Relais an heißt Tür auf
  } else {
    DoorBool = 1;  //Pin high bedeutet Relais aus heißt Tür zu
  }

  display.setCursor(0, 40);
  if (DoorBool == 0) {
    display.print("Relais an / Tur auf");
    display.drawPixel(79, 40, WHITE);
    display.drawPixel(81, 40, WHITE);
  }

  if (DoorBool == 1) {
    display.print("Relais aus / Tur zu");
    display.drawPixel(85, 40, WHITE);
    display.drawPixel(87, 40, WHITE);
  }

  display.setCursor(0, 56);
  display.print("Temperatur: ");
  display.print(rtc.getTemperature());
  display.print("'C");  //Temperatur ausm RTC holen und aufs Display legen


  digitalWrite(DoorPin, DoorBool);

  display.invertDisplay(now.second() % 2);  //Display im 1Hz rythmus alternierend invertieren um einbrennen zu reduzieren
  display.display();                        //Jezt alles aufs Display und 1sec warten
  delay(1000);
}